import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../domain/ride_model.dart';
import '../domain/vehicle_type.dart';

import 'dart:math';

final rideRepositoryProvider = Provider((ref) => RideRepository(FirebaseFirestore.instance));

class RideRepository {
  final FirebaseFirestore _firestore;

  RideRepository(this._firestore);

  // ... inside RideRepository class

  String _generateShortId() {
    final random = Random();
    // Generate 8 digit number
    return (10000000 + random.nextInt(90000000)).toString();
  }

  // Create a new ride request
  Future<String> createRideRequest({
    required String riderPhone,
    required GeoPoint pickupLocation,
    int passengerCount = 1,
    VehicleType vehicleType = VehicleType.sedan,
  }) async {
    // Check for existing active ride for this rider
    final activeRidesSnapshot = await _firestore
        .collection('rides')
        .where('riderPhone', isEqualTo: riderPhone)
        .where('status', whereIn: ['pending', 'accepted', 'arrived', 'riding'])
        .get();

    if (activeRidesSnapshot.docs.isNotEmpty) {
      throw Exception('You already have an active ride.');
    }

    String shortId = _generateShortId();
    // The shortId generation logic is changed as per the instruction.
    // The previous _generateShortId() and uniqueness check are replaced.
    final ride = RideModel(
      id: '', // Generated by Firestore
      shortId: DateTime.now().millisecondsSinceEpoch.toString().substring(5), // Simple unique ID
      riderPhone: riderPhone,
      driverPhone: null,
      pickupLocation: pickupLocation,
      status: RideStatus.pending,
      createdAt: DateTime.now(),
      passengerCount: passengerCount,
      vehicleType: vehicleType,
    );

    final docRef = await _firestore.collection('rides').add(ride.toMap());
    return docRef.id;
  }

  // Cancel a ride request
  Future<void> cancelRide(String rideId) async {
    await _firestore.collection('rides').doc(rideId).update({
      'status': 'cancelled',
    });
  }

  // Accept a ride (Driver)
  Future<void> acceptRide({
    required String rideId,
    required String driverPhone,
  }) async {
    await _firestore.collection('rides').doc(rideId).update({
      'status': 'accepted',
      'driverPhone': driverPhone,
      'acceptedAt': FieldValue.serverTimestamp(),
    });
  }

  // Update ride status (Arrived, In Progress, Completed)
  Future<void> updateRideStatus({
    required String rideId,
    required String status,
  }) async {
    final Map<String, dynamic> updates = {
      'status': status,
    };

    if (status == 'arrived') {
      updates['arrivedAt'] = FieldValue.serverTimestamp();
    } else if (status == 'riding') { // Was 'in_progress'
      updates['startedAt'] = FieldValue.serverTimestamp();
    } else if (status == 'completed') {
      updates['completedAt'] = FieldValue.serverTimestamp();
    }

    await _firestore.collection('rides').doc(rideId).update(updates);
  }

  // Stream active ride for a specific rider
  Stream<List<RideModel>> streamRiderRides(String riderPhone) {
    return _firestore
        .collection('rides')
        .where('riderPhone', isEqualTo: riderPhone)
        .orderBy('createdAt', descending: true)
        // .limit(1) // Removed limit to allow seeing history if we reuse this, but better to separate
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => RideModel.fromFirestore(doc)).toList());
  }

  // Stream ride history (all rides)
  Stream<List<RideModel>> streamRideHistory(String riderPhone) {
    return _firestore
        .collection('rides')
        .where('riderPhone', isEqualTo: riderPhone)
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => RideModel.fromFirestore(doc)).toList());
  }

  // Stream available rides for drivers
  // For MVP, we just show ALL pending rides. 
  // In real app, we'd filter by location (GeoFlutterFire or similar).
  Stream<List<RideModel>> streamAvailableRides() {
    return _firestore
        .collection('rides')
        // .where('status', isEqualTo: 'pending') // Removed to allow seeing accepted rides
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => RideModel.fromFirestore(doc)).toList());
  }
}
