import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../domain/ride_model.dart';
import '../domain/ride_options.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'dart:math';

final rideRepositoryProvider = Provider((ref) => RideRepository(FirebaseFirestore.instance));

class RideRepository {
  final FirebaseFirestore _firestore;

  RideRepository(this._firestore);

  // ... inside RideRepository class

  String _generateShortId() {
    final random = Random();
    // Generate 8 digit number
    return (10000000 + random.nextInt(90000000)).toString();
  }



  // ... inside createRideRequest
  Future<String> createRideRequest({
    required String riderPhone,
    required String pickupAddress,
    required String destinationAddress,
    required RideOptions options,
  }) async {
    final user = FirebaseAuth.instance.currentUser;
    try {
      final activeRidesSnapshot = await _firestore
          .collection('rides')
          .where('riderPhone', isEqualTo: riderPhone)
          .where('status', whereIn: ['pending', 'accepted', 'arrived', 'riding'])
          .get();
      
      if (activeRidesSnapshot.docs.isNotEmpty) {
        throw Exception('You already have an active ride.');
      }
    } catch (e) {
      rethrow;
    }

    String shortId = _generateShortId();
    // The shortId generation logic is changed as per the instruction.
    // The previous _generateShortId() and uniqueness check are replaced.
    final ride = RideModel(
      id: '', // Generated by Firestore
      shortId: DateTime.now().millisecondsSinceEpoch.toString().substring(5), // Simple unique ID
      riderPhone: riderPhone,
      driverPhone: null,
      pickupAddress: pickupAddress,
      destinationAddress: destinationAddress,
      status: RideStatus.pending,
      createdAt: DateTime.now(),
      passengerCount: options.passengerCount,
      vehicleType: options.vehicleType,
      acceptPets: options.acceptPets,
      acceptWheelchair: options.acceptWheelchair,
      acceptCargo: options.acceptCargo,
    );

    try {
      final docRef = await _firestore.collection('rides').add(ride.toMap());
      return docRef.id;
    } catch (e) {
      rethrow;
    }
  }

  // Cancel a ride request
  Future<void> cancelRide(String rideId) async {
    await _firestore.collection('rides').doc(rideId).update({
      'status': 'cancelled',
    });
  }

  // Accept a ride (Driver)
  Future<void> acceptRide({
    required String rideId,
    required String driverPhone,
  }) async {
    await _firestore.collection('rides').doc(rideId).update({
      'status': 'accepted',
      'driverPhone': driverPhone,
      'acceptedAt': FieldValue.serverTimestamp(),
    });
  }

  // Update ride status (Arrived, In Progress, Completed)
  Future<void> updateRideStatus({
    required String rideId,
    required String status,
  }) async {
    final Map<String, dynamic> updates = {
      'status': status,
    };

    if (status == 'arrived') {
      updates['arrivedAt'] = FieldValue.serverTimestamp();
    } else if (status == 'riding') { // Was 'in_progress'
      updates['startedAt'] = FieldValue.serverTimestamp();
    } else if (status == 'completed') {
      updates['completedAt'] = FieldValue.serverTimestamp();
    }

    await _firestore.collection('rides').doc(rideId).update(updates);
  }

  // Stream active ride for a specific rider
  Stream<List<RideModel>> streamRiderRides(String riderPhone) {
    return _firestore
        .collection('rides')
        .where('riderPhone', isEqualTo: riderPhone)
        .orderBy('createdAt', descending: true)
        // .limit(1) // Removed limit to allow seeing history if we reuse this, but better to separate
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => RideModel.fromFirestore(doc)).toList());
  }

  // Stream ride history (all rides)
  Stream<List<RideModel>> streamRideHistory(String riderPhone) {
    return _firestore
        .collection('rides')
        .where('riderPhone', isEqualTo: riderPhone)
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => RideModel.fromFirestore(doc)).toList());
  }

  // Stream available rides for drivers
  // For MVP, we just show ALL pending rides. 
  // In real app, we'd filter by location (GeoFlutterFire or similar).
  Stream<List<RideModel>> streamAvailableRides() {
    return _firestore
        .collection('rides')
        // .where('status', isEqualTo: 'pending') // Removed to allow seeing accepted rides
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => RideModel.fromFirestore(doc)).toList());
  }
  // Get a single ride by ID
  Future<RideModel> getRide(String rideId) async {
    final doc = await _firestore.collection('rides').doc(rideId).get();
    if (!doc.exists) {
      throw Exception('Ride not found');
    }
    return RideModel.fromFirestore(doc);
  }

  // Stream a single ride
  Stream<RideModel> streamRide(String rideId) {
    return _firestore
        .collection('rides')
        .doc(rideId)
        .snapshots()
        .map((doc) {
          if (!doc.exists) throw Exception('Ride not found');
          return RideModel.fromFirestore(doc);
        });
  }
}
